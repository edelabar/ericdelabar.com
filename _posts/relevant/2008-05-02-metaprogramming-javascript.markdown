---
layout: post
title: Duck Punching JavaScript - Metaprogramming with Prototype by Eric DeLabar
metadesc: 
class: post
changefreq: never
priority: 0.9
category: relevant
---
<h1>Duck Punching JavaScript - Metaprogramming with Prototype</h1>
<p>First, let me explain the title for those of you who live in Java world.  The term Duck Punch comes from Ruby programmers and refers to the concept of <a href="http://en.wikipedia.org/wiki/Duck_typing">duck typing</a> used by Ruby and other languages; <q>if it walks like a duck and quacks like a duck, I would call it a duck.</q>  With that being said, <a href="http://en.wikipedia.org/wiki/Monkey_patch">duck punching is summed up nicely by Patrick Ewing with the&nbsp;following</a>:</p>
<blockquote><p>Well, I was just totally sold by Adam, the idea being that if it walks like a duck and talks like a duck, it's a duck, right? So if this duck is not giving you the noise that you want, you've got to just punch that duck until it returns what you&nbsp;expect.</p></blockquote>
<p>It is slightly violent, but makes for a good article title.  Now, getting to the point, <a href="http://en.wikipedia.org/wiki/Metaprogramming"><cite>metaprogramming</cite></a> is writing programs that write or manipulate programs, including themselves, at runtime.  This type of programming can be accomplished in many languages but is currently a pretty hot topic in languages such as <a href="http://www.ruby-lang.org/">Ruby</a> and <a href="http://groovy.codehaus.org/">Groovy</a>.  Java has a similar concept known as <a href="http://en.wikipedia.org/wiki/Aspect_Oriented_Programming">Aspect Oriented Programming (<abbr title="Aspect Oriented Programming"><span class="caps">AOP</span></abbr>)</a>, which introduces <a href="http://en.wikipedia.org/wiki/Pointcut">pointcuts</a> to a program that can then be modified at runtime via bytecode manipulation or dynamic method&nbsp;proxies. </p>
<p>My example library/method below allows a <a href="http://www.prototypejs.org/">Prototype</a>-enabled class to have every one of its methods wrapped with a before and/or after method to introduce additional functionality at runtime.  This concept is demonstrated by <a href="http://www.ericdelabar.com/examples/metaprogramming-javascript/index.html">this example</a>, note that the modification occurs on the class level and any existing or future instances of that class are affected.  Thanks to <a href="http://www.prototypejs.org/">Prototype <span class="caps">JS</span></a>, this code is pretty&nbsp;simple:</p>

{% render_gist https://gist.github.com/raw/885501/bb61ff75f9316bb53f09f74ef1838c9bfc0e223e/metaprogramming-javascript.js %}

<p>This code relies on one of the core concepts of JavaScript <abbr title="Object Oriented Programming"><span class="caps">OOP</span></abbr>; a JavaScript object is nothing more than an associative array.  Knowing this, when passed a class, we can get a list of all class member names using the Prototype <a href="http://www.prototypejs.org/api/object/keys"><code>Object.keys</code> method</a> as shown on line 4.  Once we have the member names, we loop through all members (line 5) of the class.  For each member we check if it <a href="http://www.prototypejs.org/api/object/isfunction">is a function</a> (line 7).  If it is, we alias the function (line 9) and create a new function (line 10) in its place that wraps the aliased function with calls to the before (line 11) and after (line 20) functions we pass in.  Notice the use of <code>clazz.prototype</code> starting on line 9, the <code>prototype</code> keyword is necessary to modify the class.  If you rewrote this method slightly and didn't specify the <code>prototype</code> keyword you could modify an individual instance of the class instead of all running instances.  Also notice the <a href="http://www.prototypejs.org/api/function/curry"><code>curry</code> method</a> on line 16, <a href="http://en.wikipedia.org/wiki/Currying">currying is a metaprogramming technique</a> (provided as a helper by Prototype <span class="caps">JS</span>) where a function is modified with each call so that the arguments passed into it become part of the function and are no longer necessary.  This allows us to pass an arbitrary number of arguments into the aliased method.  (Remember, in JavaScript, arguments do not need to be defined for a function and can be accessed via the arguments&nbsp;array.)</p>
<p>The above code can be called on any class in the document by running the following code, assuming before and after are pre-existing functions and SampleClass is the desired&nbsp;class:</p>

{% render_gist https://gist.github.com/raw/885501/6030ba1b786227dccc10c052d88a8eb1ef03adfb/metaprogramming-javascript.usage.js %}

<p>You can see a complete (although pretty useless) <a href="http://www.ericdelabar.com/examples/metaprogramming-javascript/index.html">example of this method here</a>, or view the source code for <a href="http://www.ericdelabar.com/examples/metaprogramming-javascript/test.js">the test</a> or the <a href="http://www.ericdelabar.com/examples/metaprogramming-javascript/sampleClass.js">sample&nbsp;class</a>.</p>
<p>So, where is this useful?  Since we're simulating <span class="caps">AOP</span>, we can use this for any <a href="http://en.wikipedia.org/wiki/Cross-cutting_concern">cross-cutting concern</a>, a perfect example being logging or profiling.  Watch for a future article where I use this technique to automatically implement <a href="http://www.ericdelabar.com/2008/04/javascript-getelementbyid-performance.html">JavaScript profiling similar to what I did in my article on the dollar function</a> using this technique.  One final note for the Prototype geniuses out there, Prototype does provide a <a href="http://www.prototypejs.org/api/function/wrap"><code>wrap</code> method</a> that provides this functionality, but if you used that you never would have learned all the neat things about JavaScript in this&nbsp;example!</p>